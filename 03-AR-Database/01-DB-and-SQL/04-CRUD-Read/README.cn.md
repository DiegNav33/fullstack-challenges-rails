### 背景与目标

本练习和下面练习的目标是实现每一个 `CRUD` 操作，并建立一个 [Hacker News](https://news.ycombinator.com) 的山寨版。HackerNews 一个非常简约的社交新闻网站（专注于计算机科学与技术），用户可以在网站上提交文章链接，而其他用户则可以选择为这些文章链接"upvote"（投赞成票）。

**注意**：在本练习中，与上一个练习类似，我们**已经提供了**`DB`全局变量，因此你无需实例化一个新的`SQLite3::Database`。与上次练习不同的是，这次的 `DB` 是一个**全局变量**，这意味着在代码中的任何地方都可以访问它，因此无需像上次挑战那样将db作为参数传递。只需在代码中的任何地方使用 `DB.execute` 就可以了（不过，你也可以看看 `spec/models/post_spec.rb` 以了解 `DB` 变量是如何创建的）。

## 测试

我们还为你准备了一个 `test.rb` 文件，其中 `DB` 全局变量的创建方式与 `spec/models/post_spec.rb` 中的相同。你可以使用该文件调用和测试你的方法。

### 详细说明

#### 第一部分：设置我们的模型

我们提供了一个 `post.rb` 文件，其中定义了一个 `Post` 类，用于处理数据库中定义如下的 `posts` 表：

```sql
CREATE TABLE `posts` (
  `id`  INTEGER PRIMARY KEY AUTOINCREMENT,
  `title` TEXT,
  `url` TEXT,
  `votes`  INTEGER
);
```

#### `#initialize`

与往常一样，创建模型时我们首先要做的是定义模型应具有的属性。因此，使用上面的表格定义，在你的 `Post` 类中添加 `initialize` 方法，并将表格列存储为实例变量。

#### 获取器和设置器

下一步是定义哪些属性是**可读的**，哪些是**可写的**。对于我们的HackerNews 山寨版来说：

  - `id`可以查看，但不能编辑
  - `title`和`URL`可以查看和编辑
  - 投票数`votes`可以被查看，可以通过投赞成票查增加，但不应直接编辑

#### 第二部分：阅读

在这部分练习中，我们将重点实现**R**ead（`CRUD`中的`R`）操作。

在两种情况下，我们可能希望从数据库中**读取**：

  1. 为了_查找_一个特定的文章
  2. 或者，为了获取所有的_所有_文章

让我们用以下两种方法来实现这两种情况：

#### `#find`

在`Post`类上实现一个**类**方法`find(id)`，该方法将一个整数作为参数（文章 id），并返回一个 `Post`实例。

 **重要**： 你的方法的第一行应该是这样的:

```rb
DB.results_as_hash = true
```

让我们使用**伪代码**来帮助我们分解所需的步骤：

```ruby
# TODO：编写SQL语句来根据id查询文章
# TODO：使用DB.execute执行SQL查询
# TODO：将找到的文章作为文章实例返回！
```

☝️ 请确保使用程序中定义的全局变量 `DB`，无需自己将其实例化！

💡 提示：请务必注意从 `DB.execute` 方法返回的**数据类型**与您的模型中需要的**数据类型**。如何确保我们最终获得一个 `Post` 实例？

##### SQL注入

正如我们在讲座中学到的，我们还需要保护我们的`find`方法，防止 **SQL 注入**。作为提醒，SQL 注入是一个严重的安全问题，攻击者可以通过恶意查询数据库来干扰应用程序。潜在的影响包括，例如，允许不怀好意的用户访问受限数据，即社会保险号、信用卡或密码😱。在某些情况下，攻击者甚至可以更改或删除数据，对应用程序造成永久性破坏。如果您想了解有关 SQL 注入的更多信息并查看一些示例，请查看这个联系最后部分的_附加资源_部分。

为防止数据库被 SQL 注入，绝不能将用户数据直接插入SQL查询，而应使用 `?` [**占位符**](http://ruby.bastardsbook.com/chapters/sql/#placeholders-sqlite-gem) 代替。

ℹ️ 在本练习中，为防止SQL注入，您需要向 `.execute` 方法传递多个参数。记得查看讲座幻灯片，复习一下如何做到这一点。

#### `#all`

接下来，在`Post`类上实现一个**类**方法`all`，该方法不需要参数，将返回一个数组，其中包含数据库中的每个`Post`实例。

让我们再次使用**伪代码**来帮助我们分解步骤：

```ruby
# TODO：编写从数据库中获取所有文章的SQL查询
# TODO：使用 DB.execute 执行SQL查询
# TODO：返回一个包含所有文章的数组 - 包含的都是文章实例！
```

就像在 `#find` 方法中一样，我们需要注意从 `DB.execute` 方法中返回的**数据类型**与我们的模型中需要的**数据类型**的对比！

**选做练习： 重构**

你可能会注意到，当我们需要将数据库中的响应数据转换为 `Post` 实例时，我们在 `#find` 和 `#all` 方法中有一些重复的代码。你可以尝试将这段代码重构为一个名为 `build_record(row)` 的私有方法，该方法从数据库中获取一行数据并将其转换为一个 `Post` 实例。然后在任何需要转换数据的地方使用这个 `#build_record` 方法。

## 其他资源

SQL 注入是一种攻击类型，在这种攻击中，这个用户不会只向 `find` 方法传递一个普通的整数 `id` ，而是会添加一个邪恶的字符串来破坏你的数据。如果你查看规范中的SQL查询，就会明白我们的意思。

你可以阅读[这篇Medium文章](https://medium.com/@yelstin.fernandes/how-to-add-items-to-a-database-table-using-ruby-sqlite3-74dcd8f931f9) 和[这个StackOverflow答案](https://stackoverflow.com/questions/13462112/inserting-ruby-string-into-sqlite#answer-13462218) 来了解SQL注入👌。

如果你想了解SQL注入的实际操作，[黑进这家银行](https://www.hacksplaining.com/exercises/sql-injection#/start)你就会明白了！

**永远不要相信用户数据**！
