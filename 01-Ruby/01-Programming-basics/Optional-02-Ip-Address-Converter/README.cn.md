## 背景与目标

这是一个你们这些做题很快的同学们准备的code kata。我们想用不同的记号法（notation）来处理数字。在这个例子中我们将讨论一下IPv4地址。

你可能已经见过一些IPv4地址了，例如`192.168.0.1`，或者`173.194.40.200`。你可以用`host` 命令来获取一个域名的ip地址。例如：

```bash
host www.lewagon.com
```

你将看到`www.lewagon.com`是一个映射到特定地址的Heroku域名的别名。

现在你可能想找到自己的ip地址？你的电脑拥有一个由Wifi路由器提供的IP地址，你可以通过在终端中键入`ips`得到该地址。你和其他同学共享着一个IP地址，如果想确定这个Wifi路由器的公共ip地址，你可以输入:

```bash
curl https://ipinfo.io/json
```

## 详细说明

一个IPv4地址是一个32位（32-bit）数字，它可用于识别互联网上的设备。
虽然计算机将IP地址读写为32位数字，但我们更喜欢以点号分隔的十进制记法来读取它们，意思就是把这个32位数分成4块，转换为十进制，并用点号分隔开。

在这个挑战中，你将创建`ip_to_num` 方法：这个方法会将一个ip地址字符串转化成一个数字。以及`num_to_ip`方法：这个方法可以把数字转化为ip地址字符串。

这就是我们在二进制中表示8位（8-bit）的方式：

```ruby
00000000
# => 0

11111111
# => 255
```

我们怎样把二进制转化为十进制呢？这将用到2的指数。

```ruby
2^7 | 2^6 | 2^5 | 2^4 | 2^3 | 2^2 | 2^1 | 2^0 |
128 |  64 |  32 |  16 |  8  |  4  |  2  |  1  |
```

所以一个32位IP地址应该是：
```ruby
00000000.00000000.00000000.00000000
# => 0.0.0.0
11111111.11111111.11111111.11111111
# => 255.255.255.255
```

例子：

如果我们以`37.160.113.170`为例。
我们必须以第一个8位开始：`37`.
我可以从`37`减去`128`吗？不能，所以我们把`0`赋予`128`。

```ruby
128 |  64 |  32 |  16 |  8  |  4  |  2  |  1  |
 0  |
```
我可以从`37` 中减去`64`吗？不能，所以我们把`0`赋予`64`.

```ruby
128 |  64 |  32 |  16 |  8  |  4  |  2  |  1  |
 0  |  0
```
我可以从`37`中减去`32`吗？可以，所以我们把`1`赋予`32`，且我们的余数现在是5.

```ruby
128 |  64 |  32 |  16 |  8  |  4  |  2  |  1  |
 0  |  0  |   1 |
```
我可以从`5`中减去`16`吗？不能，所以我们把`0`赋予`16`.

```ruby
128 |  64 |  32 |  16 |  8  |  4  |  2  |  1  |
 0  |  0  |   1 |   0 |
```
我可以从`5`中减去`8`吗？不能，所以我们把`0`赋予`8`.

```ruby
128 |  64 |  32 |  16 |  8  |  4  |  2  |  1  |
 0  |  0  |   1 |  0  |  0  |
```
我可以从`5`中减去`4`吗？可以，所以我们把`1`赋予`4`，且我们的余数现在是`1`.

```ruby
128 |  64 |  32 |  16 |  8  |  4  |  2  |  1  |
 0  |  0  |   1 |  0  |  0  |  1  |
```
我可以从`1`中减去`2`吗？不能，所以我们把`0`赋予`2`.

```ruby
128 |  64 |  32 |  16 |  8  |  4  |  2  |  1  |
 0  |  0  |   1 |  0  |  0  |  1  |  0  |
```
我们可以从`1`中减去`1`吗？可以，所以我们把`1`赋予`1`，且我们的余数是`0`.

```ruby
128 |  64 |  32 |  16 |  8  |  4  |  2  |  1  |
 0  |  0  |   1 |  0  |  0  |  1  |  0  |  1  |
```
- 所以`37`在二进制中是`00100101`！（`32 + 4 + 1`）。
对其它3个八位（8-bit）数字重复上述步骤，你将得到完整的二进制IP。

- `160`的二进制是`10100000`! (`128 + 32`).
- `113`的二进制是`01110001`! (`64 + 32 + 16 + 1`).
- `170`的二进制是`10101010`! (`128 + 32 + 8 + 2`).

移除`.`就得到`00100101101000000111000110101010`，并运用你的方法：`536870912 (2^29) + 67108864 (2^26) + 16777216 (2^24) + 8388608 (2^23) + 2097152 (2^21) + 16384 (2^14) + 8192 (2^13) + 4096 (2^12) + 256 (2^8) + 128 (2^7) + 32 (2^5) + 8 (2^3) + 2 (2^1)  = 631271850`.

所以```631271850```是IP地址```37.160.113.170```的十进制数字。

你的目标是写两个方法：一个把ip变成数字，另一个把数字变成ip。

```ruby
ip_to_num("37.160.113.170")
# => 631271850

num_to_ip(631271850)
# => "37.160.113.170"
```
