## 背景和目标

**getter** 是从实例变量 **请求** 信息的方法。
**setter** 是一个从实例变量方法 **更改** 信息的方法。

在本练习中，我们将实现一个简单的自动售货机 (`VendingMachine` Ruby类)。用户可以以特定的价格购买零食，用户可以进入机器，投入一些硬币，然后按下“购买”按钮。

## 详细说明

**不要马上 `rake` ** 这个练习的目的是让你去 **阅读** 一些Ruby代码，并试图找出 `VendingMachine`  类中缺少的代码。

### 场景 - 购买商品

打开 `lib/buying_scenario.rb`，并逐行阅读。你可以做一些[橡皮鸭调试](https://rubberduckdebugging.com/)一行一行地对你的鸭子解释代码做了什么。完成后，让我们运行代码：

```bash
ruby lib/buying_scenario.rb
```

代码将 **失败** 并显示错误消息。这是练习的开始！你需要弄清楚需要在 `lib/vending_machine.rb` 中添加什么代码，使让这个场景生效！

### 场景 - 重新填充自动售货机

这种情况更简单。现在我们从一个空的自动售货机开始，所以需要一个技术人员来给它补充一些零食！

```bash
ruby lib/refilling_scenario.rb
```

代码同样会失败。你需要找出要在`lib/vending_machine.rb`中添加到什么代码！

### 最后，我们可以 `rake`

当你对这两种场景感到满意时，请检查代码是否正确：

```bash
rake
```

在你的 `VendingMachine` 类可能还有一些工作要做 😉

## （高级）一些开放性问题 🤔

1. 你可能已经注意到，在这两个场景文件中，都有一个 `display` 的方法。我们如何重构这段代码，使之更“面向对象”呢？这样做，我们如何才能改变我们的reader，使之向外部世界暴露 **更少** 的信息？这里需要记住的概念是[**封装**](https://zh.wikipedia.org/wiki/%E5%B0%81%E8%A3%9D_(%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88))
2. 你使用了一个writer来更新重新填充时零食的数量。我们如何才能将此代码更改为使用实例方法而不是此编写器？为什么更好？
