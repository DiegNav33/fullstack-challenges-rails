## Background & Objectives

Time to implement a "Longest-word game" with a cool web-interface! For some of you, it will seem familiar.

Before jumping into the exercise, [read the rules](https://github.com/lewagon/fullstack-challenges/tree/master/01-Ruby/06-Parsing/02-Numbers-and-Letters).

‚õîÔ∏è If you worked on that exercise, please do not copy/paste the solution, try to rewrite it from scratch.

## Setup

There is no `rake` here, and do not create your Rails app in `fullstack-challenges`. You should be creating your app in the following directory (Kitt will sadly no longer display your score):

```bash
cd ~/code/<user.github_nickname>
rails new rails-longest-word-game --skip-active-storage --skip-action-mailbox
cd rails-longest-word-game
git add .
git commit -m "rails new"
gh repo create --public --source=.
git push origin master
```

## Specs

Let's think about the UI for our game. What do we need?

1. A page to display the game settings (random letters), with a form for the user to type a word. A button to submit this form.
2. A page receiving this form, computing the user score and displaying it.

### Routing & Controller

Using the right command line command, generate the `GamesController` with two actions `new` and `score`. The `new` action will be used to display a new random grid and a form. The form will be submitted (with `POST`) to the `score` action.

Open your `routes.rb` file and tweak the routes automatically generated by the previous command. In the end, `rails routes` should return something like this:

```bash
Prefix Verb URI Pattern      Controller#Action
   new GET  /new(.:format)   games#new
 score POST /score(.:format) games#score
```

### Generating a new game

Have a look at your old Ruby code. How did you generate an `Array` of ten random letters? In the `new` action of the `GamesController`, create a new `@letters` instance variable storing these random letters from the alphabet. Then display it in the view. You should get something like this:

![](https://raw.githubusercontent.com/lewagon/fullstack-images/master/rails/longest-word-game/new_game.png)

### Submitting a word

We need to add a form below the letters so that the user can fill a suggestion and submit it.

It should `POST` to the `/score` action in the `GamesController`.

We will also disable for now a Rails feature which ajaxifies `post` requests sent from forms. Your HTML form tag should look like this:

```html
<form action="TODO" method="TODO" data-turbo="false">
  <!-- ... -->
</form>
```

You will need to add the line below into your `form`:

```erb
<%= hidden_field_tag :authenticity_token, form_authenticity_token %>
```

This will add a hidden input field with an `authenticity_token` that ensures the `POST` request is coming from your website and not from another. Read [this stack overflow thread](https://stackoverflow.com/questions/941594/understanding-the-rails-authenticity-token) if you want to learn more about [CSRF](https://en.wikipedia.org/wiki/Cross-site_request_forgery) and why Rails adds this security layer by default!

![](https://raw.githubusercontent.com/lewagon/fullstack-images/master/rails/longest-word-game/new_game_with_form.png)

### At the other side of the form

Let's check that the form is being correctly set by inspecting what we get in `params`. They are two ways, the first one is to add `raise` in your controller code:

```ruby
# app/controllers/games_controller.rb

# [...]
  def score
    raise
  end
```

Go to the `/new` page, fill a word and submit the form. You should get a **RuntimeError** from Rails, with a console at the bottom. You can type `params` to inspect what got sent:

![](https://raw.githubusercontent.com/lewagon/fullstack-images/master/rails/longest-word-game/raise.png)

Another way is to add either the `binding.break`, `binding.b` or `debugger` keyword as a breakpoint in your controller code and to trigger the request by submitting the form. It will open a debugging session in your terminal `rails s` process. You can then type `next` to execute the next line or `continue` to finish rendering the view:

```bash
Started POST "/score" for 127.0.0.1 at 2022-08-16 14:42:49 +0200
Processing by GamesController#score as HTML
  Parameters: {"authenticity_token"=>"[FILTERED]", "letters"=>"I G U E Z Y T H E W", "word"=>"toto"}
[8, 17] in ~/code/lewagon/rails-longest-word-game/app/controllers/games_controller.rb
     8|     @letters += Array.new(5) { (('A'..'Z').to_a - VOWELS).sample }
     9|     @letters.shuffle!
    10|   end
    11|
    12|   def score
=>  13|     debugger
    14|   end
    15|
    16|   private
    17|
=>#0  GamesController#score at ~/code/lewagon/rails-longest-word-game/app/controllers/games_controller.rb:13
  #1  ActionController::BasicImplicitRender#send_action(method="score", args=[]) at ~/.rbenv/versions/3.1.2/lib/ruby/gems/3.1.0/gems/actionpack-7.0.3/lib/action_controller/metal/basic_implicit_render.rb:6
  # and 68 frames (use `bt' command for all frames)
(rdbg)
```

### Computing the score

Time to implement the `GamesController#score` logic. Do we have all the information at hand? What do we need? Do we need to pass more information through the `POST` request? Have a look at [`hidden_field_tag`](http://api.rubyonrails.org/v5.1/classes/ActionView/Helpers/FormTagHelper.html#method-i-hidden_field_tag).

We want to handle three scenarios:

1. The word can't be built out of the original grid ‚ùå
2. The word is valid according to the grid, but is not a valid English word ‚ùå
3. The word is valid according to the grid and is an English word ‚úÖ

(You can use [this API](https://dictionary.lewagon.com/) to check if a word is valid.)

At the bottom of the results, add a `link_to` to go back to the New game page.

![](https://raw.githubusercontent.com/lewagon/fullstack-images/master/rails/longest-word-game/cant_be_built.png)

![](https://raw.githubusercontent.com/lewagon/fullstack-images/master/rails/longest-word-game/not_english_word.png)

![](https://raw.githubusercontent.com/lewagon/fullstack-images/master/rails/longest-word-game/congrats.png)

### Designing your app

Install Bootstrap by copy-pasting the `link` tag [from the documentation](https://getbootstrap.com/docs/5.1/getting-started/introduction/#css) in the `head` of your layout:

```erb
<!-- app/views/layouts/application.html.erb -->
<!-- [...] -->
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
```

Write your own CSS in the `app/assets/stylesheets/application.css` file.

Try to match the design from the screenshots üé®

### Adding score (Optional)

The user will play many games, it makes sense to store each score and add it to a grand total. We can have a rule where the score for each game is the number of letters in every valid words (but you can be more creative, take the square of the number of letters? Something else?).

Today is not about the database, so we don't have Active Record to help us store information and retrieve it between two HTTP requests. In Rails, another mechanism exists to persist information **accross** HTTP requests: the [session](http://guides.rubyonrails.org/action_controller_overview.html#session).

Try to use a Rails session to store, compute and display a grand score.

### Testing (Optional)

‚ö†Ô∏è Please skip this section if you don't feel at ease yet with Rails internal. You can always come back here later in the day after completing the Longest Word Game exercise.

First, delete the `test/controllers/games_controller_test.rb` file if it got generated. We will be doing [**System Testing**](http://guides.rubyonrails.org/testing.html#system-testing). The goal of this kind of testing is to automate all the manual testing of "code editing / go to the browser / reload the page / check if this is working". Everything you did manually in the browser can be done _via_ code!

We will use _Headless Chrome_ for System Testing. It's a browser without a user interface, well-suited for this kind of automated tests. Before running your system tests you need to make sure you have a **recent** version of Chrome on your system (not Chromium). It's available for both macOS and Ubuntu.

After the installation you can open the following file and replace **all** its content with:

```ruby
# test/test_helper.rb
ENV['RAILS_ENV'] ||= 'test'
require_relative '../config/environment'
require 'rails/test_help'

class ActiveSupport::TestCase
  fixtures :all
end

Capybara.register_driver :headless_chrome do |app|
  options = Selenium::WebDriver::Chrome::Options.new(args: %w[no-sandbox headless disable-gpu window-size=1400,900])
  Capybara::Selenium::Driver.new(app, browser: :chrome, options: options)
end
Capybara.save_path = Rails.root.join('tmp/capybara')
Capybara.javascript_driver = :headless_chrome
```

Then in the following file **update** this line:

```ruby
# test/application_system_test_case.rb
require "test_helper"
class ApplicationSystemTestCase < ActionDispatch::SystemTestCase
  driven_by :headless_chrome # Update this line
end
```

Ready? Let's dive into Rails Testing.

In the terminal, run the following to create the test file:

```bash
rails g system_test games
```

Great! We have a brand new file in ` test/system/games_test.rb`! What do we want to test?

1. Going to the `/new` game page displays a random grid.
1. You can fill the form with a random word, click the play button, and get a message that the word is not in the grid.
1. You can fill the form with a one-letter consonant word, click play, and get a message that the word is not a valid English word.
1. You can fill the form with a **valid** English word (that's hard because there is randomness!), click play and get a "Congratulations" message.

Let's do the first one together:

```ruby
# test/system/games_test.rb
require "application_system_test_case"

class GamesTest < ApplicationSystemTestCase
  test "Going to /new gives us a new random grid to play with" do
    visit new_url
    assert test: "New game"
    assert_selector "li", count: 10
  end
end
```

Run the test in the terminal with:

```bash
rails test:system
```

‚ö†Ô∏è If you are getting a `Webdrivers::BrowserNotFound: Failed to find Chrome binary` error, you need to install the latest version of Chrome:

```bash
 # macOS
brew install --cask google-chrome

# Ubuntu
wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb
sudo apt install ./google-chrome-stable_current_amd64.deb
rm -rf google-chrome-stable_current_amd64.deb
```

Once you have installed it, you can relaunch the tests with `rails test:system`.

In this test, I am visiting the `/new` URL and making sure I get ten letters to play with.

Now your turn! Try to implement the three other tests using Capybara `fill_in` and `click_on` methods.
